#import "@preview/modern-technique-report:0.1.0": *
#import "@preview/cetz:0.3.1": *
#import "@preview/cetz-plot:0.1.0": plot

#let userstories = yaml("user-stories.yaml")
#let storyproperty(story, key) = {
  if story.keys().contains(key) {
    story.at(key)
  } else {[]}
}
#let horizontalCell(content, colour: black) = table.cell(
  colspan: 5,
  align: horizon,
  inset: (y: 4pt),
  fill: colour,
)[#text(size:8pt)[#content]]
  
#let month = ("Oct", "Nov", "Dec", "Jan", "Feb", "Mar")
#let random(x) =  {
  x = int(x * 1031)
  x = x.bit-xor(x.bit-lshift(13))
  x = x.bit-xor(x.bit-rshift(17))
  x = x.bit-xor(x.bit-lshift(5))
  calc.rem(int(x),4)
}

/*
headers and footers
*/
// colours!!!! use these for formatting colours :)
#let themegradientcolour = color.map.plasma
#let themegradient = gradient.linear(..themegradientcolour)
#let doubletheme = (..color.map.plasma, ..color.map.plasma)
#let lastheading = "None"

#set page(
  // footer
  footer: context {
    if counter(page).get().first() > 0 [   
      #text(size:0.85em)[
        #h(1fr)
        #counter(page).display() 
      ]
    ]
  },
  
  // header
  header: context {
    let before = query(selector(heading.where(level:1)).before(here()))
    let after = query(selector(heading.where(level:1)).after(here()))
    let section = if after.len() == 0 {
      // show previous if in last section
      before.last().body
    } else if before.len() == 0 { 
      // show "Western University" if we haven't reached the first section
      [Western University]
    } else if after.first().location().page() == here().page() {
      // if new section is on this page, show that new section
      after.first().body
    } else {
      // if no new section, show previous section
      before.last().body
    }
    /*
    let elems = query(heading.where(level:1))
    let section
    if elems.len() == 0 {section = [Western University]}
    else if elems.len() == query(heading.where(level:1)).len() {
      section = query(heading).last().body
    }
    else {section = elems.last().body}
    */
    // actual header lol
    if counter(page).get().first() > 0 [
      #place(top+left,dx:-200pt,
        rect(width: 180%, height:10pt, fill: themegradient)
      )
      #text(size:0.85em)[
        _SE Capstone Project Proposal 2024-2025_
        #h(1fr)
        #section        
      ]
    ]
  }
)

/*
cover page
*/
// set cover page to page 0
#counter(page).update(0)
// template to simplify things
#show: modern-technique-report.with(
  // title!!!
  title: {
    
    v(-2em)
    align(top+center)[#text(size: 50pt)[STELLA]\ #v(-.75em)#text(tracking: 1pt, size:10pt)[Simulated Training Environments\ #v(-5pt)and Large Learning Automata]]
},
  // subtitle???
  subtitle: {
    v(.5em)
    align(center)[#text(size:24pt)[Sprint Plans 1 & 2]]
    v(0em)
  },
  // little block thing top left
  series: [SE 4450 Software Engineering Design II \
    Team 32 _Capstone Project_],
  // names :D
  author: [#set text(13pt);\ #grid(
    align: (left , left + horizon, right),
    columns: (1fr, 2fr, 1.5fr),
    inset: 6pt,
    [*_Members_*], [Beaudry Hajji, Isabelle],[ibeaudr\@uwo.ca],
    [],[Hoffman, Madelyn], [mhoffm32\@uwo.ca],
    [],[Bazina-Grolinger, Dominic],	[dbazinag\@uwo.ca],
    [],[Su, James], 	[tsu32\@uwo.ca],
    [*_Advisors_*], [Yimin Yang],[yimin.yang\@uwo.ca],
  )#place(bottom + right, dy:20pt)[#set text(15pt); *Western University*]],
  // date
  date: [\ \ #v(6pt)#rotate(9deg, [November 6, 2024])],
  
  // GRADIENT slice at the bottom
  background: scale(100%)[#image("bg.png")] ,// [#rect(width: 100%, height:100%, fill: (gradient.conic(..color.map.rainbow)))],
  font: "Montserrat",
) 

// table of contents is auto generated by template 

// text settings
#set par(first-line-indent: 3em, justify: true, leading: 1em)
// gross fix for the stupid indent bug
// https://github.com/typst/typst/issues/311
#show heading: it => [#it #text(size:0.1em)[#h(0.0em)]#v(-0.1em)]

#let tablecolours = color.map.plasma.at(8)
#let tablethemeindex = 1

#set table(
  fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(2).darken(25%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1{
      gray.lighten(80%)
    } else {
      gray.lighten(60%)
    }
  },
  stroke: none,//(x,y) => if (y==0) {0pt} else {gray.lighten(0%)+1pt},
  inset: (x: 5pt, y:10pt) ,
)
#show table.cell: it => {
  if it.y == 0 {
    set text(white)
    it
  }
  else {  
    set text(black)
    it
  }
}


/*
introduction
*/
= Team Details
#v(-1em)
/* 
(a) Discuss the overview of this sprint.
(b) Clearly state who the SCRUM master (team leader) is and mention your meeting schedules.
(c) Include risks or challenges for this sprint, if you have any.
*/
== Team Roles
#v(-1em)

#align(center)[
  #table(
    columns: (15em, 10em),
    align: left,
    table.header(
      [Team Member], [Roles]
    ),
    [James Su], [Scrum Master\ Developer],
    [Dominic Bazina-Grolinger], [Developer],
    [Isabelle Beaudry Hajji], [Developer],
    [Madelyn Hoffman], [Developer],
  )
]

== Meeting Schedule
#v(-1em)
The team will meet 1-2 times per week. Meetings will be 2 hours in length with scheduled sessions as follows:
- Wednesdays: 3:30 PM - 5:30 PM when class not in session
- Fridays: 11:30 AM - 1:30 PM
These regular meetings will ensure ongoing progress tracking, collaborative problem-solving, and alignment on project milestones. Additional sessions may be scheduled as needed to address any specific challenges or issues that may arise, or to review project phases.

= User Stories and Point Estimates
#v(-1em)
== User Stories
#v(-1em)
Listed below are STELLA's project requirements in the User Story format. 
The primary user of STELLA will be other developers and system integrators looking to implement our agent and tools into new techniques or physical models. We want to ensure that STELLA's toolkit is efficient to use, while easy to monitor and modify during development.

#let storytable = ()
#{
  let storyid = 0
  set text(hyphenate: false)
  for story in userstories.stories {
    let section = storyproperty(story, "section") 
    if section != [] {
      storytable.push(
        table.cell(fill: gray.darken(40%), inset: 5pt, colspan: 3, rowspan: 2, text(white, size: 11pt)[#align(center)[#section]])
      )
    }
    storyid += 1
    storytable.push((
      [#storyid],
      storyproperty(story, "name"),
      storyproperty(story, "story"),
    ))
  }
}

#set table(
  fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(3).darken(25%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1{
      gray.lighten(60%)
    } else {
      gray.lighten(40%)
    }
  },
)
#set par(justify: false)
#table(
  columns: (0.15fr, 0.5fr, 1fr),
  align: (left, left, left),
  //[User Story ID], [Task Requirement], [User Story],
  table.header(
    [ID],[Name],[User Story]
  ),
  ..storytable.flatten()
)

#set par(justify: true)
== Poker Game Estimate
#v(-1em)
To determine the number of story points for each requirement, we used the Poker Game Estimate.
Story points are limited to values in the Fibonnaci Sequence (1, 2, 3, 5, 8, ...) to describe the order of magnitude of effort required for each story.
The poker game estimate involves the following process:

#align(left)[
  #enum(
    indent: 20pt,
    [Each team member individually picks a value for the story points.],
    [The group shares their decisions and rationale with each other.],
    [If there is a consensus, the process is complete.\ If not, each member reconsiders their valuation and the process repeats]
  )
]
Below, the final number of points for each user story is shown, as well as the reasoning for each value that the group agreed upon.

#set table(
  fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(4).darken(25%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1{
      gray.lighten(80%)
    } else {
      gray.lighten(40%)
    }
  },
)

#let pointstable = ()
#{
  let storyid = 0
  set text(hyphenate: false)
  for story in userstories.stories {
    storyid += 1
    pointstable.push((
      [#storyid],
      storyproperty(story, "name"),
      storyproperty(story, "points"),
      storyproperty(story, "reason"),
    ))
  }
}

#set par(justify: false)
#table(
  columns: (0.15fr, 0.5fr, 0.2fr, 1fr),
  align: (left, left, left),
  table.header(
    [ID],[Name],[Points], [Conclusive Reason]
  ),
  ..pointstable.flatten()
)

#let names = ("I.B.H", "M.H", "D.B", "J.S")
#let namecounter = 0

= Sprint One
#v(-1em)
== Sprint Overview
#v(-1em)
The goal of this sprint is to have a very simple and working agent. It will not be refined or optimized fully, but we would like to have a good foundation for testing and optimization for the next sprint. The goal is to have a working CARLA environment, as well as an agent that can interact with that environment. Performance metrics are not important, but we want to be able to view those metrics for future use. We start by configuring the simulation environment, and build a development framework around it. Pipelines must be setup to transfer information back and forth efficiently. Then, an agent can be started. This initial agent only needs to set the foundation for later work, like being able to receive images from the simulator, and send actions in return. With a preliminary agent completed, metrics and performance data needs to be collected and sent to loggers so that they can be used when testing the agent. Upon completion, we have a fully functional environment that can take autonomous driving algorithms in a modular way and test them in CARLA.

// hihi
== Risks and Challenges
#v(-1em)
This sprint is important for later work, as it sets the foundation for sprint 2. If the structure of the initial agent is inadequate or inflexible, it could limit further testing and optimization. Setting up and integrating the CARLA simulator for basic movement and sensor initialization is a crucial step in providing a solid foundation for our agent. If any issues arise in configuring CARLA or integrating its API, this could delay all other tasks as CARLA is the primary environment for the agent's operations. Initializing and integrating camera and LiDAR sensors, as well as preprocessing their data, may pose a risk as sensor data could be too complex or noisy. This may complicate the process of converting it into usable formats for the agent, delaying sensor integration and impacting real-time testing and performance tracking. Ensuring the agent can effectively interpret sensor data without compromising on performance is a challenge, especially if responsiveness is affected by large data volume. Aside from technical risks and challenges, effective communication and collaboration will be the most essential to avoid delays. Misalignment on priorities or insufficient sharing of updates may impact the overall progress and quality of the sprint deliverables.

#set table(
  fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(5).darken(15%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1{
      gray.lighten(80%)
    } else {
      gray.lighten(40%)
    }
  }, stroke: (x,y) => if (y==0) {0pt} else {gray.lighten(60%)+1pt},
)
#pagebreak()
== Team Working Agreement
#let gray-bg = rgb(169, 169, 169)
#align(center)[
#table(
    columns: 2,
    align: center,
    table.header(table.cell(colspan: 2, [Team Working Agreement])),
    table.cell(colspan: 2, text(gray.lighten(80%))[Work Scheduling],fill: gray.darken(30%), inset: 8pt),
    table.cell(rowspan: 4, [Working Hours]),
    [Monday: 4pm to 8pm], 
    [Tuesday 4pm to 8pm],
    [Wednesday 6pm to 9pm], 
    [Thursday 4pm to 8pm],
    [Daily Scrum], [12 PM - 12:15 PM],
    table.cell(colspan: 2, text(gray.lighten(80%))[Collaboration],fill: gray.darken(30%), inset: 8pt),
    [Communication and Tools], [Discord],
    [Project Planning],[GitHub Projects],
    [Collaboration and Version Control],[GitHub],
    table.cell(colspan: 2, text(gray.lighten(80%))[Goals],fill: gray.darken(30%), inset: 8pt),
    [Sprint Goal],[To have a simple agent that will provide a good foundation for testing and optimization in the next sprint.],
)
]
== User Stories and Tasks

#let sprint1table = ()
#{
  let storyid = 0
  set text(hyphenate: false)
  for story in userstories.stories {
    storyid += 1
    if story.keys().contains("sprint") and story.sprint != 1 {continue}
    let taskscount = 1
    let tasksexist = false
    if story.keys().contains("tasks") {
      taskscount = story.tasks.len()
      tasksexist = true
    }
    let date = if "due-date" in story.keys() {story.due-date} else {4.5}
    date = month.at(int(date)) + " " + str(int(30 * calc.rem(date, 1)))
    sprint1table.push((
      table.cell(
        rowspan: taskscount,
        align: horizon,
        [#storyid. #storyproperty(story, "name")],
      ),
    ))
    if tasksexist {
      let taskid = 0
      for task in story.tasks {
        taskid += 1
        sprint1table.push((
          [#storyid.#taskid],
          storyproperty(task, "name"),
          storyproperty(task, "workload"),
          [
            #{
              //storyproperty(task, "assigned")
              namecounter += 1
              names.at(random(namecounter))
            }\
          #date],
        ))
      }
    } else {
      sprint1table.push((
        [], [], [], []
      ))
    }
  }
}

#set par(justify: false)
#table(
  columns: (1fr, 0.25fr,1fr, 0.5fr, 0.5fr),
  align: (left, left, left),
  table.header(
    [User Story], [Task ID], [Task Description], [Workload Estimation],[Assignee/Due Date]),
  ..sprint1table.flatten()
)
#set table(
  fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(6).darken(15%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1 {
      gray.lighten(80%)
    } else {
      gray.lighten(40%)
    }
  },
)

== Burn Down Chart

#let sprint1plot = ()
  
#{
  let sprint1data = ()
  for story in userstories.stories {
    if storyproperty(story, "sprint") == 1 {
      sprint1data.push(if "due-date" in story.keys() {story.due-date} else {2})
    }
  }
  sprint1data = sprint1data.sorted()

  let step = 1 / sprint1data.len()
  let lastdate = 1
  let datecounter = 1
  for date in sprint1data {
    
    if lastdate != date {
      sprint1plot.push((lastdate,datecounter))
      lastdate = date
    }
    datecounter -= step
  }
  sprint1plot.push((lastdate, datecounter))
}


#canvas(length: 65pt, {
  plot.plot(size: (6,3), 
  x-tick-step: 1,
  x-format: v => {
    if v < 6 {
      move(dx: 15pt)[#month.at(calc.rem(int(v), 6))]
    } else {[]}
  }, 
  x-label: "Month",
  x-min: 1,
  x-max: 2.5,
  y-tick-step: 1,
  y-format: h => {if h == 0 {[0%]}else {[100%]}},
  y-label: "Backlog Remaining",
  y-min: 0,
  y-max: 1,
  {
    plot.add(sprint1plot, style: (stroke: 3pt + themegradient)
  )
  }) 
})



= Sprint Two
#v(-1em)
== Sprint Overview
#v(-1em)
The goal of this sprint is to utilize the environment built in the first half. 
A well built environment should allow for rapid testing and prototyping of agent variants, which we will combine and test in a variety of ways. The development environment will also be improved continually, through the addition of features like checkpointing. Testing and optimization will also be an important part of this sprint, to allow for the best performance in the final deliverables.  

== Risks and Challenges
#v(-1em)
The complexity of the framework quickly builds throughout sprint 2. The challenge of integrating and testing complex new features could lead to unexpected behaviour or compatibility issues within the agent. Ensuring compatibility across different components could lead to dependency issues that may affect the overall system stability. Real-time data processing for tasks may also pose as a challenge to the system's performance. Tasks like error logging, metric monitoring, and environmental condition adjustments could put strain on the system under complex scenarios or heavy load. Given the wide range of tasks and features targeted for completion in this sprint, meeting deadlines could be a challenge. Limited time may affect the ability to test and refine complex functionalities. Time management, consistent meetings, and thorough communication will be key to meeting deadlines and delivering a completed and optimized final product.

== Team Working Agreement
#let gray-bg = rgb(169, 169, 169)
#align(center)[
#table(
    columns: 2,
    align: center,
    table.header(table.cell(colspan: 2, [Team Working Agreement])),
    table.cell(colspan: 2, text(gray.lighten(80%))[Work Scheduling],fill: gray.darken(30%), inset: 8pt),
    [Working Hours],
    [TBD (schedules pending)],
    [Daily Scrum], [12 PM - 12:15 PM],
    table.cell(colspan: 2, text(gray.lighten(80%))[Collaboration],fill: gray.darken(30%), inset: 8pt),
    [Communication and Tools], [Discord],
    [Project Planning],[Github Projects],
    [Collaboration and Version Control],[GitHub],
    table.cell(colspan: 2, text(gray.lighten(80%))[Goals],fill: gray.darken(30%), inset: 8pt),
    [Sprint Goal],[Polish sprint 1 agent and add more complicated features.],
)
]

== User Stories and Tasks

#let sprint1table = ()
#{
  let storyid = 0
  set text(hyphenate: false)
  for story in userstories.stories {
    storyid += 1
    if (not story.keys().contains("sprint")) or story.sprint != 2 {continue}
    let taskscount = 1
    let tasksexist = false
    if story.keys().contains("tasks") {
      taskscount = story.tasks.len()
      tasksexist = true
    }
    sprint1table.push((
      table.cell(
        rowspan: taskscount,
        align: horizon,
        [#storyid. #storyproperty(story, "name")],
      ),
    ))
    if tasksexist {
      let taskid = 0
      for task in story.tasks {
        taskid += 1
        let date = if "due-date" in story.keys() {story.due-date} else {4.5}
        date = month.at(int(date)) + " " + str(int(30 * calc.rem(date, 1)))
        sprint1table.push((
          [#storyid.#taskid],
          storyproperty(task, "name"),
          storyproperty(task, "workload"),
          [
            #{
              //storyproperty(task, "assigned")
              namecounter += 1
              names.at(random(namecounter))
            }\
          #date],
        ))
      }
    } else {
      sprint1table.push((
        [], [], [], []
      ))
    }
  }
}

#set par(justify: false)
#table(
  columns: (1fr, 0.25fr,1fr, 0.5fr, 0.5fr),
  align: (left, left, left),
  table.header(
    [User Story], [Task ID], [Task Description], [Workload Estimation],[Assignee / Due Date]),
  ..sprint1table.flatten()
)

== Burn Down Chart

#let sprint2plot = ()
  
#{
  let sprint2data = ()
  for story in userstories.stories {
    if storyproperty(story, "sprint") == 2 {
      sprint2data.push(if "due-date" in story.keys() {story.due-date} else {4})
    }
  }
  sprint2data = sprint2data.sorted()

  let step = 1 / sprint2data.len()
  let lastdate = 3
  let datecounter = 1
  for date in sprint2data {
    if lastdate != date {
      sprint2plot.push((lastdate,datecounter))
      lastdate = date
    }
    datecounter -= step
  }
  sprint2plot.push((lastdate, datecounter))
}

#canvas(length: 65pt, {
  plot.plot(size: (6,3), 
  x-tick-step: 1,
  x-format: v => {
    if v < 6 {
      move(dx: 15pt)[#month.at(calc.rem(int(v), 6))]
    } else {[]}
  }, 
  x-label: "Month",
  x-min: 3,
  x-max: 5.5,
  y-tick-step: 1,
  y-format: h => {if h == 0 {[0%]}else {[100%]}},
  y-label: "Backlog Remaining",
  y-min: 0,
  y-max: 1,
  {
    plot.add(sprint2plot, style: (stroke: 3pt + themegradient)
  )
  }) 
})


= Project and Sprint 
== Using the Backlog
The purpose of the project backlog is to help track the group's project as we complete each story task. 
Currently, a few user stories are already underway, as each story is completed it will be marked off, but it must fit our acceptance criteria as outlined later on in this section. 
In the case that problems do arise and story points cannot be completed in their allotted time frame a prioritization discussion will commence at the next stand-up meeting. During this time the priority and importance of that story will be determined; if necessary, timelines for story completions may be adjusted.
The backlog also contains user stories that are not covered in either sprint, but may be implemented continuously or if time allows.
\ \
//unindenting this line would make it look better I think
Stories marked as "Complete" must be:
#move(dx: 10pt)[#list(
  [Reviewed by at least one other group member], 
  [Fully functional and integrated into the project],
  [Every class/function/etc documented with relevant instructions or comments],
  [Tested thoroughly by hand or automated test cases depending on the specific context]
  )
]
#let backlogtable = ()
#{
  let greencell = table.cell(align(center+horizon)[#emoji.checkmark], )//fill: green.darken(40%))
  let redcell = table.cell([],)//fill: red.darken(30%))
  let blankcell = table.cell([], fill: gray)
  let storyid = 0
  set text(hyphenate: false)
  for story in userstories.stories {
    storyid += 1
    
    backlogtable.push((
      table.cell(colspan: 4,
      [#storyid. #storyproperty(story, "name")]
      ),
    ))
    
    if storyproperty(story, "tasks") != [] {
      let taskid = 0
      for task in story.tasks {
        taskid += 1
        
        let status = if "status" in task.keys() {task.status} else {[]}

        let statusout = (redcell, redcell, redcell)
        if status == "in progress" {
          statusout.at(1) = greencell
        } else if status == "complete" {
          statusout.at(2) = greencell
        } else {
          statusout.at(0) = greencell
        }
        let name = storyproperty(task, "shortname")
        if name == [] {name = task.name}
        
        backlogtable.push((
          pad(left: 2em)[ #storyid.#taskid #name], ..statusout
        ))
      }
    }
    
  }
}

#set par(justify: false)
#table(
  columns: (1fr, 65pt, 65pt, 65pt),
  align: (left, left, left),
  //[User Story ID], [Task Requirement], [User Story],
  stroke: (x,y) => if (y==0) {0pt} else {gray.lighten(70%)+1pt},
  table.header(
    [User Story / Task],text(size:9pt)[Not Started],text(size:9pt)[In Progress],text(size:9pt)[Complete]
  ), fill: (x,y) => {
    if (y == 0){
      color.map.plasma.at(7).darken(15%)
      //rgb("#A800E0").darken(40%)
    }else if calc.rem(y, 2) == 1{
      gray.lighten(80%)
    } else {
      gray.lighten(60%)
    }
  },
  ..backlogtable.flatten()
)

#heading(outlined: true, level: 1, numbering: (..nums) => [])[Terms]

/* template
AV      #h(1fr)   Autonomous Vehicle        \ 
*/
#pad(2em)[
AV      #h(1fr)   Autonomous Vehicle        \ 
SOTA    #h(1fr)   State Of The Art          \
AD      #h(1fr)   Autonomous Driver(s)      \ 
SE      #h(1fr)   Simulated Environment     \  
RL      #h(1fr)   Reinforcement Learning    \
LLM     #h(1fr)   Large Language Model      \
]

/*
Bibliography
*/
//#set par(justify: false)
//#bibliography("refs.bib", title: [References], style:"institute-of-electrical-and-electronics-engineers", full: false)
